use std::str::FromStr;
use crate::ast::*;

grammar;

pub PrimitiveType: PrimitiveType = {
    "char" => PrimitiveType::Char,
    "int" => PrimitiveType::Int,
    "long" => PrimitiveType::Long,
    "float" => PrimitiveType::Float,
    "double" => PrimitiveType::Double,
    "void" => PrimitiveType::Void,
};


pub TypeSpecifier: TypeSpecifier = {
    "long" => TypeSpecifier::Long,
    "short" => TypeSpecifier::Short,
    "unsigned" => TypeSpecifier::Unsigned,
    "signed" => TypeSpecifier::Signed,
};


pub TypeQualifier: TypeQualifier = {
    "const" => TypeQualifier::Const,
    "restrict" => TypeQualifier::Restrict,
    "volatile" => TypeQualifier::Volatile,
};

pub Type: Type = {
    <q: TypeQualifier*> <s: TypeSpecifier*> <t: PrimitiveType> => Type {
        primitive: t,
        specifiers: s,
        qualifiers: q,
    }
}

pub Expr: Expr = {
    #[precedence(level = "0")]
    Identifier => Expr::Identifier(<>),
    Litteral => Expr::Litteral(<>),

    #[precedence(level = "10")] #[assoc(side="left")]
    <lhs: Expr> "*" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Mul },
    <lhs: Expr> "/" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Div },
    <lhs: Expr> "%" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Mod },

    #[precedence(level = "11")] #[assoc(side="left")]
    <lhs: Expr> "+" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Add },
    <lhs: Expr> "-" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Sub },
    
    #[precedence(level = "12")] #[assoc(side="left")]
    <lhs: Expr> "<<" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::ShiftLeft },
    <lhs: Expr> ">>" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::ShiftRight },
    
    #[precedence(level = "13")] #[assoc(side="left")]
    <lhs: Expr> "<" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LessThan },
    <lhs: Expr> ">" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::GreaterThan },
    <lhs: Expr> "<=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LessOrEqual },
    <lhs: Expr> ">=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::GreaterOrEqual },
    <lhs: Expr> "==" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Equal },
    <lhs: Expr> "!=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Different },
    
    #[precedence(level = "14")] #[assoc(side="left")]
    <lhs: Expr> "&" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::BAnd },
    <lhs: Expr> "|" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::BOr },
    <lhs: Expr> "^" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Xor },
    
    #[precedence(level = "15")] #[assoc(side="left")]
    <lhs: Expr> "&&" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LAnd },
    <lhs: Expr> "||" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LOr },
};

Identifier: String = <s:r"[_a-zA-Z]\w*"> => s.to_owned();

IntLitteral: i128 = <s:r"-?\d+"> => i128::from_str(s).unwrap();
StringLitteral: String = <s:r#""(\"|[^"])*""#> => s.to_owned();
pub Litteral: Litteral = {
    IntLitteral => Litteral::Integer(<>),
    StringLitteral => Litteral::String(<>),
}
