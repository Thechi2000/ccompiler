use std::str::FromStr;
use crate::ast::*;

grammar;

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

match {
    "auto",
    "break",
    "case",
    "char",
    "const",
    "continue",
    "default",
    "do",
    "double",
    "else",
    "enum",
    "extern",
    "float",
    "for",
    "goto",
    "if",
    "inline",
    "int",
    "long",
    "register",
    "restrict",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "struct",
    "switch",
    "typedef",
    "union",
    "unsigned",
    "void",
    "volatile",
    "while",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "+",
    "-",
    "*",
    "/",
    "%",
    "++",
    "--",
    "|",
    "&",
    "<<",
    ">>",
    "^",
    "=",
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "&=",
    "|=",
    "^=",
    ">>=",
    "<<=",
    "==",
    "!=",
    ">",
    "<",
    ">=",
    "<=",
    "&&",
    "||",
    "!",
    "~",
    ",",
    ";",
    ":",
} else {
    r"-?\d+",
    r#""(\"|[^"])*""#,
    r"[_a-zA-Z]\w*"
}

// ======================================
// ||              TYPING              ||
// ======================================

// ----------  Parsing primitive types ----------

pub PrimitiveType: PrimitiveType = {
    "char" => PrimitiveType::Char,
    "int" => PrimitiveType::Int,
    "long" => PrimitiveType::Long,
    "float" => PrimitiveType::Float,
    "double" => PrimitiveType::Double,
};

pub PrimitiveTypeSpecifier: PrimitiveTypeSpecifier = {
    "long" => PrimitiveTypeSpecifier::Long,
    "short" => PrimitiveTypeSpecifier::Short,
    "unsigned" => PrimitiveTypeSpecifier::Unsigned,
    "signed" => PrimitiveTypeSpecifier::Signed,
};

pub TypeQualifier: TypeQualifier = {
    "const" => TypeQualifier::Const,
    "restrict" => TypeQualifier::Restrict,
    "volatile" => TypeQualifier::Volatile,
};

pub ItemPrimitive: ItemPrimitive = {
    <specs: PrimitiveTypeSpecifier*> <ty: PrimitiveType> => ItemPrimitive { ty, specs },
}

// ----------  Parsing struct & unions ----------

pub StructField: (Identifier, Type) = {
    <ty: Type> <id: Identifier> ";" => (id, ty),
}

pub ItemStruct: ItemStruct = {
    "struct" <ident: Identifier?> "{" <fields: StructField*> "}" => ItemStruct { ident, fields },
}

pub ItemUnion: ItemUnion = {
    "union" <ident: Identifier?> "{" <fields: StructField*> "}" => ItemUnion { ident, fields },
}

// ----------  Parsing pointers ----------

pub ItemPointer: ItemPointer = {
    <ty: Type> "*" => ItemPointer { ty: Box::new(ty) }
}

// ----------  Parsing whole types ----------

pub ItemType: ItemType = {
    <p: ItemPrimitive> => ItemType::Primitive(p),
    <s: ItemStruct> => ItemType::ExplicitStruct(s),
    "struct" <s: Identifier> => ItemType::NamedStruct(s),
    <u: ItemUnion> => ItemType::ExplicitUnion(u),
    "union" <u: Identifier> => ItemType::NamedUnion(u),
    <p: ItemPointer> => ItemType::Pointer(p),
    "void" => ItemType::Void,
}

pub Type: Type = {
    <ty: ItemType> <quals: TypeQualifier*> => Type { ty, quals },
}

ExprReset: Expr = Expr;
// Ref: https://en.cppreference.com/w/c/language/operator_precedence.html
pub Expr: Expr = {
    #[precedence(level = "0")]
    Identifier => Expr::Identifier(<>),
    Litteral => Expr::Litteral(<>),
    "(" <e: ExprReset> ")" => e,

    // #[precedence(level = "1")]
    // <i: Identifier> "(" <p: Comma<Expr>> ")" => Expr::FunctionCall { name: i, parameters: p }

    #[precedence(level = "3")] #[assoc(side="left")]
    <lhs: Expr> "*" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Mul },
    <lhs: Expr> "/" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Div },
    <lhs: Expr> "%" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Mod },

    #[precedence(level = "4")] #[assoc(side="left")]
    <lhs: Expr> "+" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Add },
    <lhs: Expr> "-" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Sub },
    
    #[precedence(level = "5")] #[assoc(side="left")]
    <lhs: Expr> "<<" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::ShiftLeft },
    <lhs: Expr> ">>" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::ShiftRight },
    
    #[precedence(level = "6")] #[assoc(side="left")]
    <lhs: Expr> "<" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LessThan },
    <lhs: Expr> ">" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::GreaterThan },
    <lhs: Expr> "<=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LessOrEqual },
    <lhs: Expr> ">=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::GreaterOrEqual },

    #[precedence(level = "7")] #[assoc(side="left")]
    <lhs: Expr> "==" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Equal },
    <lhs: Expr> "!=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Different },
    
    #[precedence(level = "8")] #[assoc(side="left")]
    <lhs: Expr> "&" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::BAnd },
    #[precedence(level = "9")] #[assoc(side="left")]
    <lhs: Expr> "^" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Xor },
    #[precedence(level = "10")] #[assoc(side="left")]
    <lhs: Expr> "|" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::BOr },
    
    #[precedence(level = "11")] #[assoc(side="left")]
    <lhs: Expr> "&&" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LAnd },
    #[precedence(level = "12")] #[assoc(side="left")]
    <lhs: Expr> "||" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::LOr },

    #[precedence(level = "14")] #[assoc(side="right")]
    <lhs: Expr> "=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Assign },
   
    <lhs: Expr> "+=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Add },), op: BinOp::Assign },
    <lhs: Expr> "-=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Sub },), op: BinOp::Assign },
   
    <lhs: Expr> "*=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Mul },), op: BinOp::Assign },
    <lhs: Expr> "/=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Div },), op: BinOp::Assign },
    <lhs: Expr> "%=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Mod },), op: BinOp::Assign },

    <lhs: Expr> "<<=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::ShiftLeft },), op: BinOp::Assign },
    <lhs: Expr> ">>=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::ShiftRight },), op: BinOp::Assign },

    <lhs: Expr> "&=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::BAnd },), op: BinOp::Assign },
    <lhs: Expr> "^=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::Xor },), op: BinOp::Assign },
    <lhs: Expr> "|=" <rhs: Expr> => Expr::BinaryOperation { lhs: Box::new(lhs.clone()), rhs: Box::new(Expr::BinaryOperation { lhs: Box::new(lhs), rhs: Box::new(rhs), op: BinOp::BOr },), op: BinOp::Assign },
};

Identifier: String = <s:r"[_a-zA-Z]\w*"> => s.to_owned();

IntLitteral: i128 = <s:r"-?\d+"> => i128::from_str(s).unwrap();
StringLitteral: String = <s:r#""(\"|[^"])*""#> => s.to_owned();
pub Litteral: Litteral = {
    IntLitteral => Litteral::Integer(<>),
    StringLitteral => Litteral::String(<>),
}

VariableInitializer: Expr = {
    "=" <e: Expr> => e
};
VariableDeclaration: (Identifier, Option<Expr>) = {
    <i: Identifier> <v: VariableInitializer?> => (<>)
}

pub Statement: Statement = {
    <t: Type> <v: Comma<VariableDeclaration>> ";" => Statement::Declaration { type_: t, variables: v },
    <e: Expr> ";" => Statement::Expression(e),
    "if" "(" <c: Expr> ")" "{" <t: Statement*> "}" "else" "{" <f: Statement*> "}" => Statement::IfElse(IfElseStruct { condition: c, true_case: Box::new(Statement::Block(t)), false_case: Some(Box::new(Statement::Block(f))) }),
    "while" "(" <c: Expr> ")" "{" <b: Statement*> "}" => Statement::While(WhileStruct { condition: c, body: Box::new(Statement::Block(b)) }),
    "do" "{" <b: Statement*> "}" "while" "(" <c: Expr> ")" ";" => Statement::DoWhile(DoWhileStruct { condition: c, body: Box::new(Statement::Block(b)) }),
    "return" <v: Expr?> ";" => Statement::Return(ReturnStruct { value: v}),
};

FunctionParameter: (Type, Identifier) = {
    <t: Type> <i: Identifier> => (<>)
}
pub TopLevelDeclaration: TopLevelDeclaration = {
    <t: Type> <i: Identifier> "(" <p: FunctionParameter*> ")" "{" <b: Statement*> "}" => TopLevelDeclaration::Function { return_type: t, name: i, parameters: p, body: b }
}

pub File: Vec<TopLevelDeclaration> = {
    <f: TopLevelDeclaration*> => f
}
